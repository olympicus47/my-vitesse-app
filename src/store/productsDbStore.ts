import { defineStore, storeToRefs } from 'pinia'
import type { DocumentData } from 'firebase/firestore'
import { collection, getDocs, orderBy, query, where } from 'firebase/firestore'
import { useLocationsDbStore } from '../store/locationsDbStore'
import db from '~/firebase/firebaseApp'

export const useProductsDbStore = defineStore('productsDbStore', () => {
  const locationRef = useLocationsDbStore()

  const { selectedLocation: location } = storeToRefs(locationRef)

  const productsComps = ref([[{ ProductName: '', ProductEanCode: 0, ProductLocation: '', ProductQuantity: 0, ProductCriticalStock: 0, ProductMinimumStock: 0, ProductMaximumStock: 0 } as Product]])

  /* Creating a reference to the collection in the database. */
  const productsCollectionRef = collection(db, 'Inventar-Produse')
  /* //*** explanation

  given all the locations get their db ID's then map those to db queries with the id's as the filters then map those to subscriptions and finally make the lot of them reactive

  autogenerated docs below

  */

  /* It's a reactive subscription to the database. */
  // const unsubProductsFromLocations = () => ref(locations.value.map(x => x.LocationId).map(locationId => query(productsCollectionRef, where('LocatieProdus', '==', locationId), orderBy('NumeProdus', 'asc'))).map((query, index) => onSnapshot(query, {
  //   next: (productsSnapshot) => {
  //     const tempProducts = productsSnapshot.docs.slice().flatMap(product => ({
  //       ProductName: product.data().NumeProdus,
  //       ProductEanCode: product.data().EanProdus,
  //       ProductLocation: product.data().LocatieProdus,
  //       ProductQuantity: product.data().CantitateCurentaProdus,
  //       ProductCriticalStock: product.data().StocCriticProdus,
  //       ProductMinimumStock: product.data().StocMinimDorit,
  //       ProductMaximumStock: product.data().StocMaximDorit,
  //     }) as Product)
  //     console.error(tempProducts)
  //     productsComps.value[index] = tempProducts
  //   },
  // })))

  const products = ref(productsComps.value.flatMap(product => product).filter(product => !!(product.ProductLocation === `${location.value}` || product.ProductLocation === `${location.value}`)),
  )

  const getProductsOnce = ref(async () => await getDocs(query(productsCollectionRef, where('LocatieProdus', '==', location.value), orderBy('NumeProdus', 'asc'))).then(products => products.docs.flatMap(doc => doc.data())))

  return {
    // unsubProductsFromLocations,
    getProductsOnce,
    products,
    location,
  }
})

export interface Product extends DocumentData {

  ProductName: string
  ProductEanCode: number
  ProductLocation: string
  ProductQuantity: number
  ProductCriticalStock: number
  ProductMinimumStock: number
  ProductMaximumStock: number
}
